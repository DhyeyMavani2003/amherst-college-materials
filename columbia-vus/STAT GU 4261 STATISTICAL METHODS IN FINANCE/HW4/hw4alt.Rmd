```{r}
library(quadprog)
library(linprog)

efficient_frontier = function (returns, muP, mufree=0.0, w_lower_limit=-Inf, w_upper_limit=+Inf){
  #
  # w_lower_limit and w_upper_limit (if finite) are bounds on the porfolio weights such that
  # 
  # w_lower_limit <= w <= w_upper_limit
  #
  # Note: if solve.QP gives errors about convergence one can try a more restricted range for the values of muP:
  #
  # muP = seq(min(mean_vect), max(mean_vect), length.out=500)
  #
  #--
  n_stocks = dim(returns)[2]
  
  # Extract individual equity (mean return, std return) values: 
  mean_vect = apply(returns, 2, mean)
  cov_mat = cov(returns)
  sd_vect = sqrt(diag(cov_mat))
  
  # Portfolio weight constraints:
  #
  #     first condition enforce \sum w_j = 1
  #     second condition enforce \sum mu_j w_j = mu_target
  #             
  Amat = cbind(rep(1,n_stocks),mean_vect)
  bvec = c(1,NaN)
  if( is.finite(w_lower_limit) ){
    Amat = cbind(Amat, diag(1, nrow=n_stocks))
    bvec = c(bvec, w_lower_limit*rep(1,n_stocks))
  }
  if( is.finite(w_upper_limit) ){
    Amat = cbind(Amat, -diag(1, nrow=n_stocks))
    bvec = c(bvec, -w_upper_limit*rep(1,n_stocks))
  }

  # storage for results: 
  sdP = muP
  weights = matrix(0, nrow=length(muP), ncol=n_stocks)

  # find the optimal portfolios for each target expected return:
  #
  for( i in 1:length(muP) ){
    bvec[2] = +muP[i] # enforce portfolio mean constraint 
    result = solve.QP(Dmat=2*cov_mat, dvec=rep(0,n_stocks), Amat=Amat, bvec=bvec, meq=2)
    sdP[i] = sqrt(result$value)
    weights[i,] = result$solution 
  }

  # Find maximum Sharpe portfolio: 
  sharpe = ( muP - mufree ) / sdP 
  ind_ms = which.max(sharpe)

  # Find minimum variance portfolio: 
  ind_mv = which.min(sdP)
  
  list(mufree=mufree, mean_vect=mean_vect, cov_mat=cov_mat, sd_vect=sd_vect,
       muP=muP, sdP=sdP, weights=weights,
       sharpe=sharpe, max_sharpe=sharpe[ind_ms], max_sharpe_ind=ind_ms,
       min_variance=sdP[ind_mv]^2, min_variance_ind=ind_mv )
}


plot_efficient_frontier = function(result, title=''){
    #
    # Plots the output from a call to the function "efficient_frontier".
    #
    # weights[ind_ms, ] # print the weights of the tangency portfolio
    #

    # Unpack:
    #
    mufree = result$mufree
    muP = result$muP
    sdP = result$sdP
    weights = result$weights
    sharpe = result$sharpe
    ind_ms = result$max_sharpe_ind
    ind_mv = result$min_variance_ind
    mean_vect = result$mean_vect
    sd_vect = result$sd_vect
    
    max_sdP = max(c(sdP, sd_vect))
    x_lim_max = 1.05*max_sdP
    max_muP = max(c(muP, mean_vect))
    y_lim_max = 1.05*max_muP
    
    plot(sdP, muP, type='l', xlim=c(0, x_lim_max), ylim=c(0, y_lim_max), xlab='sdP', ylab='muP', main=title)
    ind3 = (muP > muP[ind_mv])
    lines(sdP[ind3], muP[ind3], type='l', lwd=3, col='red')
    points(0, mufree, cex=4, pch='*')
    grid()

    # Plot the tangency portfolio:
    #
    sdP_max = sdP[ind_ms]
    lines(c(0, sdP_max), mufree + c(0, sdP_max) * (muP[ind_ms] - mufree)/sdP[ind_ms], lwd=4, lty=1, col='blue')
    points(sdP[ind_ms], muP[ind_ms], cex=4, pch='*') # tangency portfolio

    points(sdP[ind_mv], muP[ind_mv], cex=2, pch='+') # min variance portfolio
}


maximize_expected_utility = function(returns, loglambda_vect, mufree=0.0, w_lower_limit=-Inf, w_upper_limit=+Inf){
    #
    # w_lower_limit and w_upper_limit (if finite) are bounds on the porfolio weights such that
    #
    # w_lower_limit <= w <= w_upper_limit
    #
    # Note: if solve.QP gives errors about convergence one can try a more restricted range for the values of muP:
    #
    # muP = seq(min(mean_vect), max(mean_vect), length. out=500)
    #
    #---
    n_stocks = dim(returns)[2]
    
    # Extract individual equity (mean return, std return) values:
    mean_vect = apply(returns, 2, mean)
    cov_mat = cov(returns)
    sd_vect = sqrt(diag(cov_mat))

    # Portfolio weight constraints:
    #
    # first condition enforces \sum w_j = 1
    #
    Amat = matrix(rep(1, n_stocks), nrow=n_stocks, ncol=1)
    bvec = c(1)
    if( is.finite(w_lower_limit) ){
        Amat = cbind(Amat, diag(1, nrow=n_stocks) )
        bvec = c(bvec, w_lower_limit*rep(1,n_stocks) )
    }
    if( is.finite(w_upper_limit) ){
        Amat = cbind(Amat, -diag(1, nrow=n_stocks) )
        bvec = c(bvec, -w_upper_limit*rep(1,n_stocks) )
    }
    
    # storage for results:
    weights = matrix(0, nrow=length(loglambda_vect), ncol=n_stocks)
    mu_vect = matrix(0, nrow=length(loglambda_vect), ncol=1)
    sd_vect = matrix(0, nrow=length(loglambda_vect), ncol=1)
    ExUtil_vect = matrix(0, nrow=length(loglambda_vect), ncol=1)
    
    # find the optimal portfolios for each value of lambda:
    #
    for( i in 1:length(loglambda_vect) ){
        lambda = exp(loglambda_vect[i])
        result = solve.QP(Dmat=lambda*cov_mat, dvec=mean_vect, Amat=Amat, bvec=bvec, meq=1)
        w = result$solution
        mu_vect[i] = w %*% mean_vect
        sd_vect[i] = sqrt(w %*% cov_mat %*% w)
        weights[i,] = w
        ExUtil_vect[i] = result$value
    }
    
    list(mean_vect=mean_vect, cov_mat=cov_mat, sd_vect=sd_vect,
         weights=weights, mu_vect=mu_vect, sd_vect=sd_vect, ExUtil_vect=ExUtil_vect)

}


possible_expected_returns = function(returns, B1, B2){
    #
    # Note: B1 is the UPPER bound on the weights in the portfolio and
    #      -B2 is the LOWER bound on the weights in the portfolio that is:
    #
    # -B2 <= w_i <= +B1
    #
    stopifnot (B1>=0)
    stopifnot (B2>=0)

    mean_vect = colMeans(returns)
    M = length(mean_vect)

    AmatLP1 = cbind(diag(1, nrow=M), matrix(0, nrow=M, ncol=M))
    AmatLP2 = cbind(matrix(0, nrow=M, ncol=M), diag(1, nrow=M))
    AmatLP3 = c(rep(1, M), rep(-1, M))
    AmatLP = rbind(AmatLP1, AmatLP2, AmatLP3)
    bvecLP = c(rep(B1, M), rep(B2, M), 1)
    cLP = c(mean_vect, -mean_vect)
    const.dir = c(rep('<=', 2*M), '=')

    resultLP_min = solveLP(cvec=cLP, bvec=bvecLP, Amat=AmatLP, lpSolve=TRUE, const.dir=const.dir, maximum=FALSE)
    resultLP_max = solveLP(cvec=cLP, bvec=bvecLP, Amat=AmatLP, lpSolve=TRUE, const.dir=const.dir, maximum=TRUE)

    list(minRet=resultLP_min, maxRet=resultLP_max)
}
```

```{r}
if( !require('linprog') ){
    install.packages('linprog', dependencies=TRUE, repos='http://cran.rstudio.com/')
}
library(linprog)

save_plots = FALSE

set.seed(0)

# Test the function "efficient_frontier" using the book's example on EPage 478:
#
library(Ecdat)
data(CRSPday)
R = 100*CRSPday[,4:6] # in percents
mean_vect = apply(R, 2, mean)
cov_mat = cov(R)
sd_vect = sqrt(diag(cov_mat))

# The target portfolio returns:
muP = seq(0.05, 0.14, length.out=300)
mufree = 1.3/253 

result = efficient_frontier(R, muP, mufree)

mean_vect = result$mean_vect
sd_vect = result$sd_vect
weights = result$weights
ind_ms = result$max_sharpe_ind

# Plot our results:
#
plot_efficient_frontier(result, "Duplicate Fig. 16.3")

print(weights[ind_ms, ]) # print the weights of the tangency portfolio

text(sd_vect[1], mean_vect[1], 'GE', cex=1.5)
text(sd_vect[2], mean_vect[2], 'IBM', cex=1.5)
text(sd_vect[3], mean_vect[3], 'Mobil', cex=1.5)



# Test the function "maximize_expected_utility" using the book's example on EPage 487:
#
dat = read.csv("Stock_Bond.csv", header=TRUE)
y = dat[, c(3, 5, 7, 9, 11, 13, 15, 17, 19, 21)]
n = dim(y)[1]
m = dim(y)[2]
r= y[-1,] / y[-n, ] - 1

nlambda = 250
loglambda_vect = seq(2, 8, length=nlambda)

meu_result = maximize_expected_utility(r, loglambda_vect)


# This code reproduces the output of Fig. 16.8:
#
par(mfrow=c(1, 3))
#
plot(loglambda_vect, meu_result$mu_vect, type='l', xlab='log(\u03BB)', ylab='E(return)') # \u03BB is the unicode character for the LaTex symbol $\lambda$
grid()
plot(loglambda_vect, meu_result$sd_vect, type='l', xlab='log(\u03BB)', ylab='SD(return)')
grid()
plot(meu_result$sd_vect, meu_result$mu_vect, type='l', xlab='SD(return)', ylab='E(return)', main='Efficient Frontier')
grid()
par(mfrow=c(1, 1))


# P 1: EPage 488-489:
#
dat = read.csv("Stock_Bond.csv", header=TRUE)
prices = cbind(dat$GM_AC, dat$F_AC, dat$CAT_AC, dat$UTX_AC, dat$MRK_AC, dat$IBM_AC)
n = dim(prices)[1]
returns = 100 * ( prices[2:n,] / prices[1:(n-1),] - 1 )
#pairs(returns)

mean_vect = colMeans(returns)
cov_mat = cov(returns)
sd_vect = sqrt(diag(cov_mat) )

mufree = 3/365

muP = seq(min(mean_vect), max(mean_vect), length.out=500)

result = efficient_frontier(returns, muP, mufree, w_lower_limit=-0.1, w_upper_limit=0.5)

mean_vect = result$mean_vect
sd_vect = result$sd_vect
weights = result$weights
ind_ms = result$max_sharpe_ind

if( save_plots ){ postscript("../../WriteUp/Graphics/Chapter16/chap_16_rlab_prob_1_ef.eps", onefile=FALSE, horizontal=FALSE) }

plot_efficient_frontier(result, 'Problem 1')

print(round(weights[ind_ms,], 4)) # print the weights of the tangency portfolio

text(sd_vect[1], mean_vect[1], 'GM', cex=1.5)
text(sd_vect[2], mean_vect[2], 'F', cex=1.5)
text(sd_vect[3], mean_vect[3], 'CAT', cex=1.5)
text(sd_vect[4], mean_vect[4], 'UTX', cex=1.5)
text(sd_vect[5], mean_vect[5], 'MRK', cex=1.5)
text(sd_vect[6], mean_vect[6], 'TBM', cex=1.5)

if( save_plots ){ dev.off() }


# P 2: EPage 489
#
ind = result$max_sharpe_ind

E_R_P = 0.0007 * 100 # the desired return (as a percent)
E_R_T = result$muP[ind] # the return of the tangency portfolio
c( E_R_P, E_R_T, mufree )

omega = ( E_R_P - mufree ) / ( E_R_T - mufree )
print(sprintf("omega= %10.6f", omega) )

print("Tangency porfolio weights:")
ind = result$max_sharpe_ind
print(round(omega*result$weights[ind,], 4))

S = 100000
S * omega * result$weights[ind, ]



```